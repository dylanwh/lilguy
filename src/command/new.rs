use clap::Parser;
use rust_embed::Embed;

use super::AppContext;

/// pico files are generated by build.rs
#[derive(Embed)]
#[folder = "$OUT_DIR/pico"]
struct PicoFiles;

#[derive(Embed)]
#[folder = "files"]
struct Files;

#[derive(Debug, Parser)]
pub struct New {
    /// the name of the project
    pub name: Option<String>,

    /// name of the theme to use
    #[clap(short, long, alias = "theme", default_value = "blue")]
    pub theme_color: ThemeColor,
}

// strum values
#[derive(Debug, Clone, clap::ValueEnum, strum::EnumString, strum::Display)]
#[strum(serialize_all = "lowercase")]
pub enum ThemeColor {
    Amber,
    Blue,
    Cyan,
    Fuchsia,
    Green,
    Grey,
    Indigo,
    Jade,
    Lime,
    Orange,
    Pink,
    Pumpkin,
    Purple,
    Red,
    Sand,
    Slate,
    Violet,
    Yellow,
    Zinc,
}

#[derive(Debug, thiserror::Error)]
pub enum NewError {
    #[error("cannot create directory: {0}: {1}")]
    CreateDir(String, tokio::io::Error),

    #[error("cannot write file: {0}: {1}")]
    WriteFile(String, tokio::io::Error),

    #[error("sass error: {0}")]
    Sass(#[from] Box<grass::Error>),

    #[error("tempfile error: {0}")]
    Tempfile(#[from] async_tempfile::Error),

    #[error("embedded file missing content")]
    MissingContent,
}

impl New {
    pub async fn run(self, AppContext { root }: AppContext) -> Result<(), NewError> {
        tokio::fs::create_dir_all(&root)
            .await
            .map_err(|e| NewError::CreateDir(root.to_string_lossy().to_string(), e))?;
        let sass_dir = async_tempfile::TempDir::new().await?;
        let assets_dir = root.join("assets");

        tokio::fs::create_dir_all(&assets_dir)
            .await
            .map_err(|e| NewError::CreateDir(assets_dir.to_string_lossy().to_string(), e))?;

        for file in PicoFiles::iter() {
            let path = sass_dir.join(file.as_ref());

            if let Some(parent) = path.parent() {
                tokio::fs::create_dir_all(parent)
                    .await
                    .map_err(|e| NewError::CreateDir(parent.to_string_lossy().to_string(), e))?;
            }
            let content = PicoFiles::get(file.as_ref()).ok_or(NewError::MissingContent)?;
            let content = content.data.as_ref();
            tokio::fs::write(&path, content)
                .await
                .map_err(|e| NewError::WriteFile(path.to_string_lossy().to_string(), e))?;
        }

        println!("generating pico.css from theme: {}", self.theme_color);
        let css = grass::from_path(
            sass_dir
                .join("theme")
                .join(format!("pico.{theme}.scss", theme = self.theme_color)),
            &grass::Options::default().style(grass::OutputStyle::Compressed),
        )?;
        tokio::fs::write(assets_dir.join("pico.css"), css)
            .await
            .map_err(|e| {
                NewError::WriteFile(assets_dir.join("pico.css").to_string_lossy().to_string(), e)
            })?;

        for file in Files::iter() {
            let path = root.join(file.as_ref());

            if path.exists() {
                println!("not overwriting existing file: {:?}", path);
                continue;
            }

            if let Some(parent) = path.parent() {
                tokio::fs::create_dir_all(parent)
                    .await
                    .map_err(|e| NewError::CreateDir(parent.to_string_lossy().to_string(), e))?;
            }
            let content = Files::get(file.as_ref()).ok_or(NewError::MissingContent)?;
            let content = content.data.as_ref();
            tokio::fs::write(&path, content)
                .await
                .map_err(|e| NewError::WriteFile(path.to_string_lossy().to_string(), e))?;
        }

        Ok(())
    }
}
